package com.test.extends_polymorphism_03.test1;

/*
 * 继承父类，
 * 变量重名时，子类中成员变量直接写，this.变量为子类的类变量，super.变量为父类的变量
 * 成员方法重名时，子类有该方法则使用子类的
 * 方法覆盖重写（overload），方法名，参数均一致才算是覆盖重写，
 *      其次子类方法的返回值必须小于等于父类方法的返回值范围，如原返回值类型为object，子类为String是允许的
 *      在子类的覆盖重写方法之上写上@override，编译器会自动检测
 * 子类方法的权限必须大于等于父类方法的权限修饰符
 *  public> protected> default(留空)> private
 * 子类拓展父类方法，使用super.方法名即可
 *
 * 构造方法：
 *      子类构造方法中隐含了一个super()( 此情况只存在于父类构造为无参构造方法)
 *      只有子类构造方法才能调用父类构造方法，即super(),且同时是第一个且唯一一个
 *          入股父类是有参构造方法则子类需要重新定义构方法，同时使用super(传递相应参数)
 *
 * super关键字使用：
 *          子类成员方法中访问父类的成员变量
 *                  访问父类的成员方法
 *                  访问父类的构造方法
 *this关键字：
 *          在本类成员方法中访问本类的成员变量
 *          本类成员方法中访问本类的其他成员方法，起到强调作用
 *          本类的构造方法中访问本类的其他构造方法，如无参构造调用有参构造，此时必须是该构造方法的第一个且是唯一的构造方法调用，即与super是冲突的
 *
 */
public class Teacher extends Employee {
    @Override
    public void test() {
        super.test();
        System.out.println("子类覆盖重写父类的test方法");
    }

}
